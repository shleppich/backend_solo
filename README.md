# backend_solo

Функциональные требования:
1. Разработка алгоритма для расчета рейтинга студентов на основе учебных показателей.
2. Ввод и обработка данных для анализа академической успеваемости студентов.
3. Отображение результатов расчета рейтинга в пользовательском интерфейсе.
4. Поддержка возможности ранжирования студентов на основе вычисленного рейтинга.

Нефункциональные требования:
1. Обеспечение безопасности данных студентов и результатов расчета.
2. Ускоренный алгоритм для эффективного выполнения расчетов.
3.Интуитивный пользовательский интерфейс для удобства использования.
4. Высокая производительность системы даже при обработке больших объемов данных.
5. Поддержка системы на различных устройствах и браузерах.

Существует потребность в автоматизации процесса расчета рейтинга студентов для эффективного анализа и оценки учебных результатов. Ручной расчет может быть трудоемким и подвержен ошибкам, что затрудняет объективную оценку успеваемости студентов.

   - Фронтенд: React.js
   - Бэкенд: Node.js, Express.js
   - База данных: MongoDB
   - Аутентификация: JSON Web Tokens (JWT)
   - Коммуникация: RESTful API

1. Ясность и понимание: Документирование функциональных и нефункциональных требований помогает всем участникам проекта четко понимать, что именно должно быть реализовано.
   
2. Ориентир для разработчиков: Документация служит ориентиром для разработчиков, позволяя им точно знать, как именно должна работать система и какие функциональности должны быть реализованы.
  
3. Будущая поддержка и развитие: Хорошо задокументированный проект упрощает будущую поддержку и развитие системы, так как новые участники смогут быстрее понять текущий функционал и архитектуру.


Правила работы внутри репозитория:

1. Используйте ветки (branches) для разработки:
   - Каждая задача или новая функциональность должна иметь свою собственную ветку.
   - После завершения работы над задачей объединяйте ее обратно в основную ветку (чаще всего это master или main).

2. Оформление коммитов:
   - Коммиты должны быть осмысленными и содержательными.
   - Соблюдайте единообразие в форматировании сообщений коммитов (например, по стандарту [Conventional Commits](https://www.conventionalcommits.org/)).
   
3. Правила оформления кода:
   - Соблюдайте стандарт кодирования, если он у вас есть в проекте (например, PEP8 для Python).
   - Делайте код понятным и читаемым для других разработчиков. Комментируйте сложные участки кода.
   
4. Используйте pull requests:
   - Перед вливанием изменений обычно создаются pull request'ы (или merge request'ы в GitLab) для обсуждения изменений и проверки кода другими участниками проекта.
   - В pull request'ах описывайте суть изменений и причины их внесения.

5. Работа с конфликтами:
   - В случае конфликтов объединения веток, разрешайте их вовремя.
   - Обсуждайте изменения и конфликты с другими участниками проекта.

6. Отслеживайте статус вашего кода:
   - Используйте CI/CD (Continuous Integration/Continuous Deployment) для автоматической проверки кода при изменениях.
   - Отслеживайте статус сборок и тестов перед вливанием изменений в основную ветку.

7. Регулярно обновляйте свой локальный репозиторий:
   - Периодически обновляйте свой локальный репозиторий из основной ветки, чтобы работать с актуальным кодом.
  
Выбор стратегии ведения веток в репозитории пал на Gitflow 
Обоснование выбора:

Простота и структурированность:
Gitflow предоставляет четкую и легко понятную модель ветвления, разделяющую различные типы изменений (фичи, исправления, релизы) для эффективного управления разработкой.
Стабильность основной ветки:
Основные ветки, такие как main и develop, остаются стабильными, что обеспечивает надежность и качество кода в этих ветках. Изменения поступают в них только после достаточного тестирования в отдельных ветках.

Альтернативы и их ограничения:
GitHub Flow:
Почему не подходит: Для более сложных проектов, где требуется поддержка релизов и параллельная разработка функций, GitHub Flow может быть слишком простым и неэффективным.
